# 排序
- 什么是排序？
> 一般情况下,
> 假设含 n 个记录的序列为$\{ R_1 , R_2 , ..., R_n \}$<br>
> 其相应的关键字序列为 $\{ K_1 , K_2 , ...,K_n \}$<br>
> 这些关键字相互之间可以进行比较,<br>
> 即在它们之间存在着这样一个关系 :<br>
> $$K_p1 ≤K_p2 ≤...≤K_pn$$
> 按此固有关系将上式记录序列重新排列为<br>
> $$\{ R_p1 , R_p2 , ...,R_pn \}$$
> 的操作称作排序。

- 稳定排序和不稳定排序
  
> 对于任意的数据元素序列,若排序前后所有相同关键字的相对
> 位置都不变,则称该排序方法称为稳定的排序方法。
> 
> 若存在一组数据序列,在排序前后,相同关键字的相对位置
> 发生了变化,则称该排序方法称为不稳定的排序方法。
> 
> 例如,对于关键字序列3,2,3,4,若某种排序方法排序后
> 变为2,3,3,4,则该排序方法是不稳定的

- 内部排序和外部排序

> 若整个排序过程不需要访问外存便能完成,则称此类排序问题为内部排序;
> 
> 反之,若参加排序的记录数量很大,整个序列的排序过程不可能在内存中 完成,则称此类排序问题为外部排序。


## 插入排序
插入排序三步曲
- 1.`定位：`在$R[1..i-1]$中查找$R[i]$的插入位置，$R[1..j].key \leq R[i].key < R[ j+1..i-1].key$
- 2.`挤空：`将$R[j+1..i-1]$中的所有记录均后移一个位置;
- 3.`插入：`将$R[i]$插入(复制)到$R[j+1]$的位置上。

不同的定位方法导致不同的插入算法

### 直接插入排序
> `排序过程:`整个排序过程为n-1趟插入,即先将序列中第1个记录看成是一个有序子序列,然后从第2个记录开始,逐个进行插入,直至整个序列有序

- #### 写法技巧：数组的第一个位置可以用来做临时空间，暂存数据
- #### 性能：
  - 时间复杂度：$T(n)=O(n^2)$
  - 空间复杂度：$S(n)=O(1)$
- #### 代码实现
``` c
#include <stdio.h>

const int length = 10;
typedef struct {
    int key;
    float info;
} JD;

void straisort(JD r[], int n) { // 对长度为n的序列排序
    int i, j;
    for (i = 2; i <= n; ++i) {
        r[0] = r[i];
        j = i - 1;
        while (r[0].key < r[j].key) {
            r[j + 1] = r[j];
            j--;
        }
        r[j + 1] = r[0];
    }
}

int main() {
    JD r[length];
    printf("请输入%d个数:\n", length);
    for (int i = 1; i < length + 1; ++i) {
        scanf("%d", &r[i].key);
    }
    printf("排序结果：");
    straisort(r, length);
    for (int j = 1; j < length + 1; ++j) {
        printf("%d\t", r[j].key);
    }

    return 0;
}
```

### 希尔排序（缩小增量法）
它是不稳定排序。
> 基本思想:分割成若干个较小的子文件,对各个子文件分别进行直接插入排序,当文件达到基本有序时,再对整个文件进行一次直接插入排序。

- 排序过程：
> 首先将记录序列分成若干子序列,<br>
> 然后分别对每个子序列进行直接插入排序,<br>
> 最后待基本有序时,再进行一次直接插入排序<br>
> 例如:将 n 个记录分成 d 个子序列:<br>
> { R[1],R[1+d],R[1+2d],...,R[1+kd] }<br>
> { R[2],R[2+d],R[2+2d],...,R[2+kd] }<br>
> ...<br>
> { R[d],R[2d],R[3d],...,R[kd],R[(k+1)d] }<br>
> 其中,d 称为增量,它的值在排序过程中从大到小逐渐缩小,直至最后一趟排序减为 1。


- `Hibbard's增量序列：`平均时间复杂度$T_{avg}(N) = O(N^{5/4})$；最坏时间复杂度为$O(N^{3/2})$
  $$h_k = 2^k - 1$$

- `Sedgewick's增量序列：`平均时间复杂度$T_{avg}(N) = O(N^{7/6})$；最坏时间复杂度$T_{worst}(N) = O(N^{4/3})$
$$9*4^i - 9*2^i + 1 \\or\\4^i - 3*2^i + 1$$


- 性能
  - 时间复杂度：平均$O(nlogn)-O(n^2)$；最坏$O(nlogn)-O(n^2)$
  - 空间复杂度：$O(1)$

- 代码实现

``` c
void shellsort(JD r[], int n, int d[], int T) {  // 对长度为n的序列排序,d[]为增量序列,T为序列长度
    int i, j;
    int k = 0;
    JD temp;

    while (k < T) {
        for (i = d[k] + 1; i <= n; ++i) { // i为未排序记录的位置
            temp = r[i];    // 暂存
            j = i - d[k];   // j为本组i前面一个记录的位置
            while ((j > 0) && (temp.key < r[j].key)) {
                // 组内简单插入排序
                r[j + d[k]] = r[j];
                j = j - d[k];

            }
            r[j + d[k]] = temp;
        }
        k++;
    }
}
```