# 排序
- 什么是排序？
> 一般情况下,
> 假设含 n 个记录的序列为$\{ R_1 , R_2 , ..., R_n \}$<br>
> 其相应的关键字序列为 $\{ K_1 , K_2 , ...,K_n \}$<br>
> 这些关键字相互之间可以进行比较,<br>
> 即在它们之间存在着这样一个关系 :<br>
> $$K_p1 ≤K_p2 ≤...≤K_pn$$
> 按此固有关系将上式记录序列重新排列为<br>
> $$\{ R_p1 , R_p2 , ...,R_pn \}$$
> 的操作称作排序。

- 稳定排序和不稳定排序
  
> 对于任意的数据元素序列,若排序前后所有相同关键字的相对
> 位置都不变,则称该排序方法称为稳定的排序方法。
> 
> 若存在一组数据序列,在排序前后,相同关键字的相对位置
> 发生了变化,则称该排序方法称为不稳定的排序方法。
> 
> 例如,对于关键字序列3,2,3,4,若某种排序方法排序后
> 变为2,3,3,4,则该排序方法是不稳定的

- 内部排序和外部排序

> 若整个排序过程不需要访问外存便能完成,则称此类排序问题为内部排序;
> 
> 反之,若参加排序的记录数量很大,整个序列的排序过程不可能在内存中 完成,则称此类排序问题为外部排序。


## 插入排序
插入排序三步曲
- 1.`定位：`在$R[1..i-1]$中查找$R[i]$的插入位置，$R[1..j].key \leq R[i].key < R[ j+1..i-1].key$
- 2.`挤空：`将$R[j+1..i-1]$中的所有记录均后移一个位置;
- 3.`插入：`将$R[i]$插入(复制)到$R[j+1]$的位置上。

不同的定位方法导致不同的插入算法

### 直接插入排序
> `排序过程:`整个排序过程为n-1趟插入,即先将序列中第1个记录看成是一个有序子序列,然后从第2个记录开始,逐个进行插入,直至整个序列有序

- #### 写法技巧：数组的第一个位置可以用来做临时空间，暂存数据
- #### 性能：
  - 时间复杂度：$T(n)=O(n^2)$
  - 空间复杂度：$S(n)=O(1)$
- #### 代码实现
``` c
#include <stdio.h>

const int length = 10;
typedef struct {
    int key;
    float info;
} JD;

void straisort(JD r[], int n) { // 对长度为n的序列排序
    int i, j;
    for (i = 2; i <= n; ++i) {
        r[0] = r[i];
        j = i - 1;
        while (r[0].key < r[j].key) {
            r[j + 1] = r[j];
            j--;
        }
        r[j + 1] = r[0];
    }
}

int main() {
    JD r[length];
    printf("请输入%d个数:\n", length);
    for (int i = 1; i < length + 1; ++i) {
        scanf("%d", &r[i].key);
    }
    printf("排序结果：");
    straisort(r, length);
    for (int j = 1; j < length + 1; ++j) {
        printf("%d\t", r[j].key);
    }

    return 0;
}
```





